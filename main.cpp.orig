/*
  Sailbot Hull 14
  L Marino and D Robinson,
  with D Evangelista, P Frontera, M Kutzer, A Laun
  2018

  Threaded version using mbed OS5
  Serial links between nodes
  Stepper motors with Pololu 2968 drivers (MP6500 based)
  Piher PST360 angle sensors
  Adafruit Absolute GPS
  Telemetry via ???Ubiquity???
*/

//Thread for logging time and Gps, heading and eventually encoder values is mostly complete
//control thread is a work in progress

#include "mbed.h"
#include "MBed_Adafruit_GPS.h"
#include "BNO055.h"
#include "Spektrum.h"


//universal variables for manual control
Spektrum rx(p13, p14);
PwmOut mainsail(p21);
PwmOut rudder(p22);

//universal variables for Telemetry
DigitalOut heartbeat(LED1);
Serial * gps_Serial;
Serial pc (USBTX, USBRX);
BNO055 bno(p28, p27);
char c; //when read via Adafruit_GPS::read(), the class returns single character stored here
float info; //a multiuse variable used for sending things over GPS
Timer refresh_Timer; //sets up a timer for use in loop; how often do we print GPS info?
const int refresh_Time = 2000; //refresh time in ms

union Float {       //slightly mysterious data type that we use to send data over serial
    float    m_float;
    uint8_t  m_bytes[sizeof(float)];
};
float        data;
uint8_t      bytes[sizeof(float)];
Float        myFloat;

//*********read reads yaw from IMU **************
void yaw_read()
{
    bno.get_angles();
    data = bno.euler.yaw;
    myFloat.m_float = data;
    data = myFloat.m_float;   // get the float back from the union
    pc.printf("%.1f", data);
    Thread::wait(2);
}

//********concatenate time**********
float conc(float hr, float min, float sec )
{
    return hr+(min/60.0)+(sec/3600.0);
}
//********Initialize IMU************

void bno_init(void)
{
    if(bno.check()) {
        pc.printf("BNO055 connected\r\n");
        bno.reset();
        Thread::wait(30);
        bno.setmode(OPERATION_MODE_CONFIG);
        bno.SetExternalCrystal(1);
        //bno.set_orientation(1);
        bno.setmode(OPERATION_MODE_NDOF);  //Uses magnetometer
        //bno.setmode(OPERATION_MODE_NDOF_FMC_OFF);   //no magnetometer
        bno.set_angle_units(RADIANS);
    } else {
        pc.printf("BNO055 NOT connected\r\n Program Trap.");
        while(1);
    }
}

// *****threading*****
Thread telemetry_thread;
Thread manual_control_thread;

void telemetry_callback(void);
void manual_control_callback(void);

int main()
{

    telemetry_thread.start(callback(telemetry_callback));
    manual_control_thread.start(callback(manual_control_callback));    // let the control thread do its job...
    while(1) {
        heartbeat = !heartbeat; // blink the heartbeat
        Thread::wait(100);
    } // while(1)
}//end main

void telemetry_callback(void)
{
    //uint64_t now;

    // setup
    //debug("telemetry_thread started\r\n");

    pc.baud(115200); //sets virtual COM serial communication to high rate; this is to allow more time to be spent on GPS retrieval

    gps_Serial = new Serial(p9,p10); //serial object for use w/ GPS
    Adafruit_GPS myGPS(gps_Serial); //object of Adafruit's GPS class

    myGPS.begin(9600);  //sets baud rate for GPS communication; note this may be changed via Adafruit_GPS::sendCommand(char *)
    //a list of GPS commands is available at http://www.adafruit.com/datasheets/PMTK_A08.pdf

    myGPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCGGA); //these commands are defined in MBed_Adafruit_GPS.h; a link is provided there for command creation
    myGPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ);
    myGPS.sendCommand(PGCMD_ANTENNA);

    pc.printf("Connection established at 115200 baud...\n");
    bno_init();

    Thread::wait(1000);
    refresh_Timer.start();  //starts the clock on the timer

    while(true) {
        c = myGPS.read();   //queries the GPS
        bno.get_angles();
        //check if we recieved a new message from GPS, if so, attempt to parse it,
        if ( myGPS.newNMEAreceived() ) {
            if ( !myGPS.parse(myGPS.lastNMEA()) ) {
                continue;
            }//if ( !myGPS.parse..

            if (refresh_Timer.read_ms() >= refresh_Time) {
                refresh_Timer.reset();
                //send hr
                data = myGPS.hour;               // conc(myGPS.hour, myGPS.minute, myGPS.seconds );
                myFloat.m_float = data;
                data = myFloat.m_float;   // get the float back from the union
                pc.printf("%2.0f", data);
                Thread::wait(35);
                //send min
                data = myGPS.minute;               // conc(myGPS.hour, myGPS.minute, myGPS.seconds );
                myFloat.m_float = data;
                data = myFloat.m_float;   // get the float back from the union
                pc.printf("%2.0f", data);
                Thread::wait(35);
                //send sec
                data = myGPS.seconds;               // conc(myGPS.hour, myGPS.minute, myGPS.seconds );
                myFloat.m_float = data;
                data = myFloat.m_float;   // get the float back from the union
                pc.printf("%2.0f", data);
                Thread::wait(35);

                if (myGPS.fix) {
                    //rudder and mast position will log here
                    //not yet included because we have been testing GPS without powering the motors and encoders

                    //send latitude
                    data = myGPS.latitude;
                    myFloat.m_float = data;
                    data = myFloat.m_float;   // get the float back from the union
                    pc.printf("%.2f", data);
                    Thread::wait(30);
                    //send logitude
                    data = myGPS.longitude;
                    myFloat.m_float = data;
                    data = myFloat.m_float;   // get the float back from the union
                    pc.printf("%.2f", data);
                    Thread::wait(30);
                    //send yaw
                    yaw_read();
                    //send transmittion
                    pc.printf("q");
                    Thread::wait(2000);
                }//if (myGPS.fix)
            }//if (refresh_Timer..

            //pc.printf("Location: %5.2f%c, %5.2f%c\n", myGPS.latitude, myGPS.lat, myGPS.longitude, myGPS.lon);
            //pc.printf("Speed: %5.2f knots\n", myGPS.speed,myGPS.angle, myGPS.altitude, myGPS.satellites);
            //pc.printf("yaw: %5.2f\n", bno.euler.yaw);
        }//if ( myGPS.newNMEAreceived() )
    }//while(true)

} // telemetry_callback()

void manual_control_callback(void)
{
    uint64_t now;

    // setup
    debug("manual_control_thread started\r\n");
    pc.printf("Initializing PwmOut objects for mainsail p21 and rudder p22\r\n");
    mainsail.period_ms(20);       //not exactly sure how this works
    mainsail.pulsewidth_us(1500); // amidships
    rudder.period_ms(20);
    rudder.pulsewidth_us(1500); // amidships
    // loop
    while(1) {
        now = rtos::Kernel::get_ms_count();

        if (rx.valid) {
            // set pwms
            mainsail.pulsewidth_us(rx.pulsewidth[0]); //this might be over simplified
            rudder.pulsewidth_us(rx.pulsewidth[3]);   //because besides defining pulsewidth,
        } // if valid                                 //direction must also be specified
        else {                                        //and the position is checked by encoders
            pc.printf("%d. invalid\r\n",i);
        } // not valid

        ThisThread::sleep_until(now+44); // wait until 44 ms later
    } // while(1)
} // manual_control_callback()
